// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.6.1
// source: api/mykratos/v1/m.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	M_CreateM_FullMethodName = "/api.mykratos.v1.M/CreateM"
	M_UpdateM_FullMethodName = "/api.mykratos.v1.M/UpdateM"
	M_DeleteM_FullMethodName = "/api.mykratos.v1.M/DeleteM"
	M_GetM_FullMethodName    = "/api.mykratos.v1.M/GetM"
	M_ListM_FullMethodName   = "/api.mykratos.v1.M/ListM"
)

// MClient is the client API for M service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MClient interface {
	CreateM(ctx context.Context, in *CreateMRequest, opts ...grpc.CallOption) (*CreateMReply, error)
	UpdateM(ctx context.Context, in *UpdateMRequest, opts ...grpc.CallOption) (*UpdateMReply, error)
	DeleteM(ctx context.Context, in *DeleteMRequest, opts ...grpc.CallOption) (*DeleteMReply, error)
	GetM(ctx context.Context, in *GetMRequest, opts ...grpc.CallOption) (*GetMReply, error)
	ListM(ctx context.Context, in *ListMRequest, opts ...grpc.CallOption) (*ListMReply, error)
}

type mClient struct {
	cc grpc.ClientConnInterface
}

func NewMClient(cc grpc.ClientConnInterface) MClient {
	return &mClient{cc}
}

func (c *mClient) CreateM(ctx context.Context, in *CreateMRequest, opts ...grpc.CallOption) (*CreateMReply, error) {
	out := new(CreateMReply)
	err := c.cc.Invoke(ctx, M_CreateM_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mClient) UpdateM(ctx context.Context, in *UpdateMRequest, opts ...grpc.CallOption) (*UpdateMReply, error) {
	out := new(UpdateMReply)
	err := c.cc.Invoke(ctx, M_UpdateM_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mClient) DeleteM(ctx context.Context, in *DeleteMRequest, opts ...grpc.CallOption) (*DeleteMReply, error) {
	out := new(DeleteMReply)
	err := c.cc.Invoke(ctx, M_DeleteM_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mClient) GetM(ctx context.Context, in *GetMRequest, opts ...grpc.CallOption) (*GetMReply, error) {
	out := new(GetMReply)
	err := c.cc.Invoke(ctx, M_GetM_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mClient) ListM(ctx context.Context, in *ListMRequest, opts ...grpc.CallOption) (*ListMReply, error) {
	out := new(ListMReply)
	err := c.cc.Invoke(ctx, M_ListM_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MServer is the server API for M service.
// All implementations must embed UnimplementedMServer
// for forward compatibility
type MServer interface {
	CreateM(context.Context, *CreateMRequest) (*CreateMReply, error)
	UpdateM(context.Context, *UpdateMRequest) (*UpdateMReply, error)
	DeleteM(context.Context, *DeleteMRequest) (*DeleteMReply, error)
	GetM(context.Context, *GetMRequest) (*GetMReply, error)
	ListM(context.Context, *ListMRequest) (*ListMReply, error)
	mustEmbedUnimplementedMServer()
}

// UnimplementedMServer must be embedded to have forward compatible implementations.
type UnimplementedMServer struct {
}

func (UnimplementedMServer) CreateM(context.Context, *CreateMRequest) (*CreateMReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateM not implemented")
}
func (UnimplementedMServer) UpdateM(context.Context, *UpdateMRequest) (*UpdateMReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateM not implemented")
}
func (UnimplementedMServer) DeleteM(context.Context, *DeleteMRequest) (*DeleteMReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteM not implemented")
}
func (UnimplementedMServer) GetM(context.Context, *GetMRequest) (*GetMReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetM not implemented")
}
func (UnimplementedMServer) ListM(context.Context, *ListMRequest) (*ListMReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListM not implemented")
}
func (UnimplementedMServer) mustEmbedUnimplementedMServer() {}

// UnsafeMServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MServer will
// result in compilation errors.
type UnsafeMServer interface {
	mustEmbedUnimplementedMServer()
}

func RegisterMServer(s grpc.ServiceRegistrar, srv MServer) {
	s.RegisterService(&M_ServiceDesc, srv)
}

func _M_CreateM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MServer).CreateM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: M_CreateM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MServer).CreateM(ctx, req.(*CreateMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _M_UpdateM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MServer).UpdateM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: M_UpdateM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MServer).UpdateM(ctx, req.(*UpdateMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _M_DeleteM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MServer).DeleteM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: M_DeleteM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MServer).DeleteM(ctx, req.(*DeleteMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _M_GetM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MServer).GetM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: M_GetM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MServer).GetM(ctx, req.(*GetMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _M_ListM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MServer).ListM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: M_ListM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MServer).ListM(ctx, req.(*ListMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// M_ServiceDesc is the grpc.ServiceDesc for M service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var M_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.mykratos.v1.M",
	HandlerType: (*MServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateM",
			Handler:    _M_CreateM_Handler,
		},
		{
			MethodName: "UpdateM",
			Handler:    _M_UpdateM_Handler,
		},
		{
			MethodName: "DeleteM",
			Handler:    _M_DeleteM_Handler,
		},
		{
			MethodName: "GetM",
			Handler:    _M_GetM_Handler,
		},
		{
			MethodName: "ListM",
			Handler:    _M_ListM_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/mykratos/v1/m.proto",
}
